{"ast":null,"code":"const Bytes = require(\"./bytes\");\n\nconst Nat = require(\"./nat\");\n\nconst elliptic = require(\"elliptic\");\n\nconst rlp = require(\"./rlp\");\n\nconst secp256k1 = new elliptic.ec(\"secp256k1\"); // eslint-disable-line\n\nconst _require = require(\"./hash\"),\n      keccak256 = _require.keccak256,\n      keccak256s = _require.keccak256s;\n\nconst create = entropy => {\n  const innerHex = keccak256(Bytes.concat(Bytes.random(32), entropy || Bytes.random(32)));\n  const middleHex = Bytes.concat(Bytes.concat(Bytes.random(32), innerHex), Bytes.random(32));\n  const outerHex = keccak256(middleHex);\n  return fromPrivate(outerHex);\n};\n\nconst toChecksum = address => {\n  const addressHash = keccak256s(address.slice(2));\n  let checksumAddress = \"0x\";\n\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n\n  return checksumAddress;\n};\n\nconst fromPrivate = privateKey => {\n  const buffer = new Buffer(privateKey.slice(2), \"hex\");\n  const ecKey = secp256k1.keyFromPrivate(buffer);\n  const publicKey = \"0x\" + ecKey.getPublic(false, 'hex').slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return {\n    address: address,\n    privateKey: privateKey\n  };\n};\n\nconst encodeSignature = ([v, r, s]) => Bytes.flatten([r, s, v]);\n\nconst decodeSignature = hex => [Bytes.slice(64, Bytes.length(hex), hex), Bytes.slice(0, 32, hex), Bytes.slice(32, 64, hex)];\n\nconst makeSigner = addToV => (hash, privateKey) => {\n  const signature = secp256k1.keyFromPrivate(new Buffer(privateKey.slice(2), \"hex\")).sign(new Buffer(hash.slice(2), \"hex\"), {\n    canonical: true\n  });\n  return encodeSignature([Nat.fromString(Bytes.fromNumber(addToV + signature.recoveryParam)), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.r.toString(16))), Bytes.pad(32, Bytes.fromNat(\"0x\" + signature.s.toString(16)))]);\n};\n\nconst sign = makeSigner(27); // v=27|28 instead of 0|1...\n\nconst recover = (hash, signature) => {\n  const vals = decodeSignature(signature);\n  const vrs = {\n    v: Bytes.toNumber(vals[0]),\n    r: vals[1].slice(2),\n    s: vals[2].slice(2)\n  };\n  const ecPublicKey = secp256k1.recoverPubKey(new Buffer(hash.slice(2), \"hex\"), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2); // because odd vals mean v=0... sadly that means v=0 means v=1... I hate that\n\n  const publicKey = \"0x\" + ecPublicKey.encode(\"hex\", false).slice(2);\n  const publicHash = keccak256(publicKey);\n  const address = toChecksum(\"0x\" + publicHash.slice(-40));\n  return address;\n};\n\nmodule.exports = {\n  create,\n  toChecksum,\n  fromPrivate,\n  sign,\n  makeSigner,\n  recover,\n  encodeSignature,\n  decodeSignature\n};","map":null,"metadata":{},"sourceType":"script"}