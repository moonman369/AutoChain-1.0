{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar bytes_1 = require(\"./bytes\");\n\nvar account_1 = require(\"./account\");\n\nvar Address =\n/** @class */\nfunction () {\n  function Address(buf) {\n    (0, assert_1.default)(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  Address.zero = function () {\n    return new Address((0, bytes_1.zeros)(20));\n  };\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  Address.fromString = function (str) {\n    (0, assert_1.default)((0, account_1.isValidAddress)(str), 'Invalid address');\n    return new Address((0, bytes_1.toBuffer)(str));\n  };\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  Address.fromPublicKey = function (pubKey) {\n    (0, assert_1.default)(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  };\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  Address.fromPrivateKey = function (privateKey) {\n    (0, assert_1.default)(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  };\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  Address.generate = function (from, nonce) {\n    (0, assert_1.default)(bn_js_1.default.isBN(nonce));\n    return new Address((0, account_1.generateAddress)(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  Address.generate2 = function (from, salt, initCode) {\n    (0, assert_1.default)(Buffer.isBuffer(salt));\n    (0, assert_1.default)(Buffer.isBuffer(initCode));\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  };\n  /**\n   * Is address equal to another.\n   */\n\n\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\n   * Is address zero.\n   */\n\n\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new bn_js_1.default(this.buf);\n    var rangeMin = new bn_js_1.default(0);\n    var rangeMax = new bn_js_1.default('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n\n  return Address;\n}();\n\nexports.Address = Address;","map":null,"metadata":{},"sourceType":"script"}